<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

	<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
		<meta name="viewport" content="width=device-width,initial-scale=1"/>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>
			レトロゲームのドット絵の拡大表示と EOTF の関係
		</title>
		<link rel="stylesheet" type="text/css" href="../../style.css"/>

		<!-- OGP -->
		<meta property="og:title" content="レトロゲームのドット絵の拡大表示と EOTF の関係"/>
		<meta property="og:image" content="https://yosshin4004.github.io/title_small.png"/>
		<meta property="og:site_name" content="yosshin4004.github.io" />

		<!-- OGP for twitter -->
		<meta name="twitter:card" content="summary"/>
		<meta name="twitter:site" content="@yosshin4004"/>
	</head>

	<body>
        <div class="main">
			<a href="../../index.html">
				[戻る]
			</a>

			<br/>

			<h1>
				レトロゲームのドット絵の拡大表示と EOTF の関係
			</h1>

			この文書では、
			レトロゲームを最新の PC やコンソールに移植するような場合に必要となる、
			低解像度のドット絵を高解像度ディスプレイに拡大表示する処理についてまとめます。
			そして、拡大処理で見落としがちな問題とその解決方法、および改良と高速化について触れます。

			<blockquote>
				<span class="emphasis2">
					この文書では、ごく基本的なバイリニアフィルタによる拡大処理のみを取り扱います。
				</span>
				高解像度化技術周辺や、
				CRT の走査線や画素の再現といったような内容は、
				この文書で取り扱う範囲外なので一切触れません。
				また、
				<span class="emphasis2">
					話を簡単にするため、拡大結果を sRGB 規格のディスプレイに表示するケースのみを考えます。
				</span>
				<br/>
				筆者はディスプレイの規格が専門分野ではないので、
				色の定義などの理解が甘い箇所があるかもしれません。あらかじめご了承ください。
				何か間違いがありましたら、ご指摘いただければ幸いです。
			</blockquote>


			<h2>
				概要
			</h2>

			レトロゲームが作成された当時のディスプレイは解像度が低く、
			ドットは滲んで表示されていました。
			当時のドット絵はこれを前提に描かれているため、
			当時のゲーム画面を高解像度ディスプレイに表示する際、
			ドットの滲みを再現しないと元のドット絵の雰囲気が出せない場合があります。
			<br/><br/>

			ドットの滲みを再現するには、
			単純に隣接ピクセル同士で画像をぼかすような処理を入れれば良いように思えます。
			しかしこのような処理を適切に行うには、
			ディスプレイの発色について理解する必要があります。
			<br/><br/>

			この文書では、
			技術背景について解説しながら、
			入力画像から以下のような出力画像を得る過程を解説していきます。
			<br/><br/>

			<center>
				<img src="1_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
				<img src="6_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
				<br/>
				入力画像
			</center>
			<br/>

			<center>
				<img src="4_smoothstep_gamma.png" alt="smoothstep利用" border="2" width="45%" height="45%"/>
				<img src="9_smoothstep_gamma.png" alt="smoothstep利用" border="2" width="45%" height="45%"/>
				<br/>
				出力画像
			</center>
			<br/>


			<h2>
				最近傍フィルタ と バイリニアフィルタ
			</h2>
			テクスチャピクセルの基本的なサンプリング方法として、
			最近傍フィルタとバイリニアフィルタがあります。

			<dl>
				<dt>
					<span class="emphasis1">
						最近傍フィルタ
					</span>
				</dt>
				<dd>
					指定されたテクスチャ座標の最も近くにあるピクセルを１つ選択し出力するサンプリング方法です。
					下図のようにテクスチャ座標（オレンジの破線）が指定された場合、
					最も近い位置である A のピクセルを読み取り、そのまま出力します。
					<br/><br/>

					<center>
						<img src="nearest.png" alt="最近傍フィルタ" border="2" width="30%" height="30%"/>
					</center>
					<br/>
				</dd>

				<dt>
					<span class="emphasis1">
						バイリニアフィルタ
					</span>
				</dt>
				<dd>
					指定されたテクスチャ座標の周辺の 2x2 ピクセルを取得し、
					これらを線形補間して出力するサンプリング方法です。
					下図のようにテクスチャ座標（オレンジの破線）が指定された場合、
					A B C D の 4 つのピクセルを読み取り、
					A:B:C:D = 赤:緑:黄:青 の面積比で重みづけし、線形補間した結果を出力します。
					<br/><br/>

					<center>
						<img src="bilinear.png" alt="バイリニアフィルタ" border="2" width="30%" height="30%"/>
					</center>
					<br/>
				</dd>

				<dt>
					<span class="emphasis1">
						バイリニアフィルタは要注意
					</span>
				</dt>
				<dd>
					ドットの形をそのまま拡大したいなら 最近傍フィルタ を利用し、
					ぼかして拡大したいなら バイリニアフィルタ を利用すればよさそうに思えます。
					しかし実際には、
					バイリニアフィルタの結果を正しく得るには、
					ディスプレイの EOTF を考慮する必要があり、話は単純ではありません。
					後述していきます。
				</dd>
			</dl>


			<h2>
				ディスプレイの EOTF
			</h2>

			ピクセルの値と、実際に画面から出力される光の強さの関係を把握する必要があります。

			<dl>
				<dt>
					<span class="emphasis1">
						EOTF
					</span>
				</dt>
				<dd>
					電気信号の強さ（ここではピクセル値）と画面から出力される光の強さの関係を定義する関数を、
					EOTF（Electro-Optical Transfer Function の略）と呼びます。
					EOTF は、単純な比例の式とは限りません。
					<br/><br/>
				</dd>

				<dt>
					<span class="emphasis1">
						レトロゲーム世代のディスプレイガンマ
					</span>
				</dt>
				<dd>
					レトロゲーム世代のドット絵は、
					1980～90年代当時の家庭用テレビやパソコン用ディスプレイ上で正しく見えるように調整されています。
					当時のドット絵を正しく取り扱うには、
					当時のディスプレイの発色を理解する必要があります。
					<br/><br/>
					当時のディスプレイは CRT ディスプレイです。
					CRT ディスプレイは、EOTF のような厳密な定義を持ちませんが、
					その仕組み上、電気信号の強さと出力される光の強さの関係は、
					一般に次のようになります。
<pre><code>
	L: 画面から出力される光の強さ
	V: 電気信号の強さ（ここではピクセル値）
	ガンマ値: 2.2

	L = V ^ ガンマ値

</code></pre>
					この文書では、
					レトロゲーム世代のディスプレイの EOTF として
					ガンマ 2.2 の曲線を利用していきます。
					<br/><br/>
				</dd>

				<dt>
					<span class="emphasis1">
						sRGB 規格のディスプレイ
					</span>
				</dt>
				<dd>
					一方、現世代のディスプレイでは、発色に関する厳密な定義が存在します。
					1990 年代末に出現した規格である sRGB では、
					その当時の市場のディスプレイに合わせて EOTF が定義されました。
					sRGB の EOTF は、疑似コードで示すと次のようになります。
<pre><code>
	L: 画面から出力される光の強さ
	V: 電気信号の強さ（ここではピクセル値）

	if V <= 0.04045:
	    L = V / 12.92
	else:
	    L = ((V + 0.055) / 1.055) ^ 2.4

</code></pre>
					分岐を伴ってやや複雑に見えますが、
					この疑似コードがやろうとしていることは、
					sRGB よりも先行した規格である BT.709 をベースとして、
					当時のディスプレイが広く採用していたガンマ 2.2 の曲線（CRT ディスプレイに由来）にフィットさせることです。
					sRGB ではガンマに相当する指数部が 2.4 になっていますが、
					この疑似コードの出力をグラフ上にプロットすると、
					ガンマ 2.2 の曲線にほぼ一致する結果となります。
					<br/><br/>
				</dd>


				<dt>
					<span class="emphasis1">
						sRGB の EOTF とガンマ 2.2 のグラフを比較
					</span>
				</dt>
				<dd>
					ここで、sRGB の EOTF が、ガンマ 2.2 の曲線にどの程度近いかを確認しておきます。
					<br/><br/>
					<center>
						<img src="srgb_vs_gamma.png" alt="ガンマ2.2の曲線" border="2" width="50%" height="50%"/>
					</center>
					<br/>
					ピッタリとまでは行きませんが、ほぼ一致しているように見えます。
					sRGB の EOTF は輝度が低い部分の諧調がリニアになるなど細かい差がありますが、
					そのような違いが問題とならないケースでは、
					sRGB の EOTF をガンマ 2.2 の曲線で近似する方法はうまく機能することがわかります。
					<br/><br/>
				</dd>

				<dt>
					<span class="emphasis1">
						意識しなくても良いが故の落とし穴
					</span>
				</dt>
				<dd>
					少々回りくどくなりましたが、
					要約すると、
					レトロゲーム世代のドット絵は、
					sRGB 規格のディスプレイ上であれば、
					元のピクセル値でそのまま（ビット数など精度は変換を行うものとして）表示するだけで、
					概ね同じ絵が表示されます。
					<br/><br/>

					あっさりと概ね同じ絵が表示されてしまうが故に、
					その背景にある EOTF について普段あまり意識することはありません。
					ですが、バイリニアフィルタ処理を適用する際は、
					これを意識する必要があります。
				</dd>
			</dl>



			<h2>
				バイリニアフィルタする際、EOTF を考慮する必要がある
			</h2>

			バイリニアフィルタを適用するとき、
			EOTF を考慮するかどうかで、結果が大きく異なります。
			<br/>

			<dl>
				<dt>
					<span class="emphasis1">
						白と黒のピクセル値を平均しても、中間の明るさのグレーにはならない
					</span>
				</dt>
				<dd>
					例えば、sRGB 規格のディスプレイ上で、
					RGB=255,255,255 の白と、RGB=0,0,0 の黒の、
					中間の明るさを持つグレーはどのようなピクセル値になるでしょうか？
					<br/><br/>

					単純に 255 を 2 で割り、128 とするのは間違いです。
					実験してみます。
					RGB=255,255,255 の白と、RGB=0,0,0 の黒を、チェッカー模様状に配置した画像を作ります。
					これを dot by dot で表示した状態で、ディスプレイから遠く離れて肉眼で観察すると、
					白と黒が混ざって中間の明るさのグレーを視認することが可能です。
					これと、RGB=128,128,128 のグレー画像を、sRGB 規格のディスプレイ上で表示し、見比べます。
					<br/><br/>

					<center>
						<img src="checker_128.png" alt="rgb=128,128,128" border="2" width="512" height="256" style="image-rendering: pixelated;"/>
						<br/>
						左：RGB=255,255,255 と RGB=0,0,0 のチェッカー模様
						<br/>
						右：RGB=128,128,128 で均一にフィルした画像
						<br/>
						（注）デスクトップの拡大率を 100% に設定して見比べてください
					</center>
					<br/>

					明らかに、RGB=128,128,128 のグレー（右）の方が暗く表示されていることがわかります。
					つまり 128 は 255 と 0 の中間の明るさではないことがわかります。
					<br/><br/>
				</dd>

				<dt>
					<span class="emphasis1">
						中間の明るさのグレーを作るには、EOTF を考慮する必要がある
					</span>
				</dt>
				<dd>
					まず、sRGB の EOTF から、白と黒の中間（=0.5）の出力値が得られる入力値を求めます。
					そのためには、EOTF の逆変換が必要です。
					EOTF の逆変換は OETF（Optical-Electro Transfer Function の略）と呼ばれます。
					sRGB の OETF を疑似コードで示すと以下のようになります。
<pre><code>
	L: 画面から出力される光の強さ
	V: 電気信号の強さ（ここではピクセル値）

	if L <= 0.0031308:
		V = 12.92 * L
	else:
		V = 1.055 * (L ^ (1.0 / 2.4)) - 0.055

</code></pre>
					これを利用すると、L に 0.5 が得られる時の V は 0.735... という値になります。
					この値に 255 を掛けると、8ビットのピクセル値となります。結果はおよそ 188 となります。
					<br/><br/>

					先ほどの白と黒のチェッカー模様と、RGB=188,188,188 のグレーと並ると、次のようになります。
					sRGB 規格のディスプレイ上に表示して見比べると、
					ほぼ一致することが確認できます。
					<br/><br/>

					<center>
						<img src="checker_188.png" alt="rgb=188,188,188" border="2" width="512" height="256" style="image-rendering: pixelated;"/>
						<br/>
						左：RGB=255,255,255 と RGB=0,0,0 のチェッカー模様
						<br/>
						右：RGB=188,188,188 で均一にフィルした画像
						<br/>
						（注）デスクトップの拡大率を 100% に設定して見比べてください
					</center>
					<br/>
				</dd>


				<dt>
					<span class="emphasis1">
						同様の問題はバイリニアフィルタでも発生している
					</span>
				</dt>
				<dd>
					例えばテクスチャ上に、RGB=255,255,255 の白と、RGB=0,0,0 の黒のピクセルが隣り合って配置されているとして、
					その中間の位置からバイリニアフィルタで読み取るとどうなるでしょうか？
					これまでの説明に従うと、得られるピクセル値は（端数は四捨五入するとして）RGB=128,128,128 となります。
					先ほど実験したとおり、
					これは sRGB 規格のディスプレイ上では、白と黒の中間の明るさのグレーにはなりません。
					<br/><br/>
				</dd>

				<dt>
					<span class="emphasis1">
						EOTF を考慮したバイリニアフィルタ
					</span>
				</dt>
				<dd>
					一連の問題は、EOTF を考慮したバイリニアフィルタを行うことで解決されます。
					HLSL ベースの疑似コードで示すと次のようになります。

<pre><code>
	/*
		float2 texCoord = テクスチャ座標
		float2 reso = テクスチャの解像度
		inputTexture = テクスチャ
		コードを単純化するため、いずれの EOTF もガンマ2.2の曲線としている。
	*/

	/* ピクセル単位のテクスチャ座標 */
	float2 pos = texCoord * reso;

	/* ピクセル中心の補正 */
	pos -= 0.5;

	/* バイリニア補間する４ピクセル */
	int2 ipos = int2(pos);
	float4 pixel00 = inputTexture[ipos            ];
	float4 pixel01 = inputTexture[ipos + int2(1,0)];
	float4 pixel10 = inputTexture[ipos + int2(0,1)];
	float4 pixel11 = inputTexture[ipos + int2(1,1)];

	/* ガンマ2.2 → リニアに変換 */
	pixel00.rgb = pow(pixel00.rgb, 2.2);
	pixel01.rgb = pow(pixel01.rgb, 2.2);
	pixel10.rgb = pow(pixel10.rgb, 2.2);
	pixel11.rgb = pow(pixel11.rgb, 2.2);

	/* バイリニアフィルタの補間率 */
	float2 alpha = frac(pos);

	/* 自力バイリニアフィルタ */
	float4 result =
		pixel00 * (1 - alpha.x) * (1 - alpha.y)
	+	pixel01 *      alpha.x  * (1 - alpha.y)
	+	pixel10 * (1 - alpha.x) *      alpha.y
	+	pixel11 *      alpha.x  *      alpha.y;

	/* リニア → ガンマ2.2に変換 */
	result.rgb = pow(result.rgb, 1.0/2.2);

</code></pre>
					<blockquote>
						この文書の最後で触れますが、
						GPU を利用する場合、
						この疑似コードに含まれる処理の多くはテクスチャサンプラのレベルに組み込まれており、
						シェーダコードとして実装する必要はありません。
						ここでは説明上、自力で行う実装としています。
					</blockquote>

					ここで改めて先ほどの画像を引用し、
					EOTF 考慮による効果を確認します。
					<br/><br/>

					<center>
						<img src="1_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
						<img src="6_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
						<br/>
						入力画像
					</center>
					<br/>

					<center>
						<img src="2_bilinear.png" alt="バイリニア拡大" border="2" width="45%" height="45%"/>
						<img src="7_bilinear.png" alt="バイリニア拡大" border="2" width="45%" height="45%"/>
						<br/>
						EOTF を考慮せずバイリニアフィルタした結果。
						<br/>
						正しくありません。画面全体の輝度が下がっています。
						<br/>
						フォントがやせ細って、形のニュアンスが微妙に変わってしまっています。
					</center>
					<br/>

					<center>
						<img src="3_bilinear_gamma.png" alt="EOTF考慮しつつバイリニア拡大" border="2" width="45%" height="45%"/>
						<img src="8_bilinear_gamma.png" alt="EOTF考慮しつつバイリニア拡大" border="2" width="45%" height="45%"/>
						<br/>
						EOTF を考慮してバイリニアフィルタした結果。
						<br/>
						ボケ気味なのが気になるところです（このあと修正していきます）が、
						<br/>
						画面全体の輝度は元の絵と一致しており、正しい結果です。
					</center>
					<br/>
				</dd>
			</dl>



			<h2>
				さらなる改良：ドット感を残しつつぼけさせる
			</h2>

			EOTF を考慮したバイリニアフィルタが正しい結果を出力することがわかりましたが、
			ボケ気味の絵が出るのが気になるところでした。
			ここではさらなる改良を考えます。

			<dl>
				<dt>
					<span class="emphasis1">
						ドット感を残しつつぼけさせるバイリニアフィルタ
					</span>
				</dt>
				<dd>
					ドット感を残すには、
					テクスチャのピクセル中心あたりを積極的にサンプリングするよう、
					バイリニアフィルタの補間率を調整します。
					バイリニアフィルタでは、
					補間率は 0 から 1 に単調増加する直線を利用していますが、
					これを 0 と 1 あたりで変化量が 0 になるような曲線に変更します。
					このようなケースでよく利用されるのは、次の三次曲線です。
<pre><code>
	t * t * (3 - 2 * t)

</code></pre>
					この曲線をグラフ化し、単調増加する直線（リニア）と比較すると、次のようになります。
					<br/><br/>

					<center>
						<img src="linear_vs_smoothstep.png" alt="linear_vs_smoothstep" border="2" width="50%" height="50%"/>
					</center>
					<br/>

					これを利用し、バイリニアフィルタの補間率を調整すると、次のようになります。
<pre><code>
	/* ドットがボケ過ぎないよう、バイリニアフィルタの補間率を調整 */
	alpha = alpha * alpha * (3 - 2 * alpha);

</code></pre>
					シェーダ言語では、
					このような３次関数は専用の組み込み関数である smoothstep 関数を利用することで簡潔に記述することができます。

<pre><code>
	/* ドットがボケ過ぎないよう、バイリニアフィルタの補間率を調整 */
	alpha = smoothstep(0, 1, alpha);

</code></pre>

					smoothstep 関数を利用し、先ほどの疑似コードの全体を示すと、次のようになります。
<pre><code>
	/*
		float2 texCoord = テクスチャ座標
		float2 reso = テクスチャの解像度
		inputTexture = テクスチャ
		コードを単純化するため、いずれの EOTF もガンマ2.2の曲線としている。
	*/

	/* ピクセル単位のテクスチャ座標 */
	float2 pos = texCoord * reso;

	/* ピクセル中心の補正 */
	pos -= 0.5;

	/* バイリニア補間する４ピクセル */
	int2 ipos = int2(pos);
	float4 pixel00 = inputTexture[ipos            ];
	float4 pixel01 = inputTexture[ipos + int2(1,0)];
	float4 pixel10 = inputTexture[ipos + int2(0,1)];
	float4 pixel11 = inputTexture[ipos + int2(1,1)];

	/* ガンマ2.2 → リニアに変換 */
	pixel00.rgb = pow(pixel00.rgb, 2.2);
	pixel01.rgb = pow(pixel01.rgb, 2.2);
	pixel10.rgb = pow(pixel10.rgb, 2.2);
	pixel11.rgb = pow(pixel11.rgb, 2.2);

	/* バイリニアフィルタの補間率 */
	float2 alpha = frac(pos);

	/* ドットがボケ過ぎないよう、バイリニアフィルタの補間率を調整 */
	alpha = smoothstep(0, 1, alpha);

	/* 自力バイリニアフィルタ */
	float4 result =
		pixel00 * (1 - alpha.x) * (1 - alpha.y)
	+	pixel01 *      alpha.x  * (1 - alpha.y)
	+	pixel10 * (1 - alpha.x) *      alpha.y
	+	pixel11 *      alpha.x  *      alpha.y;

	/* リニア → ガンマ2.2に変換 */
	result.rgb = pow(result.rgb, 1.0/2.2);

</code></pre>
					<br/>
				</dd>

				<dt>
					<span class="emphasis1">
						結果の確認
					</span>
				</dt>
				<dd>
					ここで改めて先ほどの画像を引用し、
					smoothstep の効果を確認します。
					<br/><br/>


					<center>
						<img src="1_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
						<img src="6_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
						<br/>
						入力画像
					</center>
					<br/>

					<center>
						<img src="3_bilinear_gamma.png" alt="EOTF考慮しつつバイリニア拡大" border="2" width="45%" height="45%"/>
						<img src="8_bilinear_gamma.png" alt="EOTF考慮しつつバイリニア拡大" border="2" width="45%" height="45%"/>
						<br/>
						補間率がリニアの場合のバイリニアフィルタ結果。
						<br/>
						ピクセルがボケ過ぎています。
					</center>
					<br/>

					<center>
						<img src="4_smoothstep_gamma.png" alt="smoothstep利用" border="2" width="45%" height="45%"/>
						<img src="9_smoothstep_gamma.png" alt="smoothstep利用" border="2" width="45%" height="45%"/>
						<br/>
						補間率に smoothstep を適用しバイリニアフィルタした結果。
						<br/>
						ピクセル感を残しつつボケています。
					</center>
					<br/>
				</dd>
			</dl>


			<h2>
				さらなる改良：高速化
			</h2>
			最後に、さらなる改良として高速化を考えます。

			<dl>
				<dt>
					<span class="emphasis1">
						GPU が利用できる場合
					</span>
				</dt>
				<dd>
					GPU が利用できる場合、ピクセル値に sRGB の EOTF を適用する処理は、
					テクスチャサンプラに任せることが可能です。
					DirectX/OpenGL の場合は、
					ピクセルフォーマットに SRGB が付いているものを指定するだけでこのような動作となります。
					sRGB の EOTF を適用する処理は、
					バイリニアフィルタが適用される前のピクセル値に対して行われます。
					従って、単にバイリニアサンプリングするだけで良いということになります。
<pre><code>
	/*
		float2 texCoord = テクスチャ座標
		inputSrgbTexture = SRGB 指定されたテクスチャ
		linearSampler = サンプラステート
		コードを単純化するため、いずれの EOTF もガンマ2.2の曲線としている。
	*/

	/* sRGB → リニアに変換し、バイリニアフィルタ適用 */
	float4 pixel = inputSrgbTexture(linearSampler, texCoord);

	/* リニア → ガンマ2.2に変換 */
	result.rgb = pow(pixel.rgb, 1.0/2.2);

</code></pre>

					ドット感を残しつつぼけさせる補正を加える場合は、以下のようになります。
<pre><code>
	/*
		float2 texCoord = テクスチャ座標
		float2 reso = テクスチャの解像度
		inputSrgbTexture = SRGB 指定されたテクスチャ
		linearSampler = サンプラステート
		コードを単純化するため、いずれの EOTF もガンマ2.2の曲線としている。
	*/

	/* ピクセル単位のテクスチャ座標 */
	float2 pos = texCoord * reso;

	/* ピクセル中心の補正 */
	pos -= 0.5;

	/* バイリニアフィルタの補間率 */
	vec2 alpha = fract(pos);

	/* ドットがボケ過ぎないよう、バイリニアフィルタの補間率を調整 */
	alpha = smoothstep(0, 1, alpha);

	/* テクスチャ座標に反映 */
	pos = floor(pos) + alpha;

	/* ピクセル中心の補正を戻す */
	pos += 0.5;

	/* sRGB → リニアに変換し、バイリニアフィルタ適用 */
	float4 pixel = inputSrgbTexture(linearSampler, pos / reso);

	/* リニア → ガンマ2.2に変換 */
	result.rgb = pow(pixel.rgb, 1.0/2.2);

</code></pre>
					<br/>
				</dd>

				<dt>
					<span class="emphasis1">
						CPU でやる場合
					</span>
				</dt>
				<dd>
					CPU で処理するしかないようなケースでは、EOTF/OETF に含まれる超越関数のコストが問題となります。
					高速な近似実装を考える必要があります。

					<dl>
						<dt>
							<span class="emphasis2">
								ガンマ2.0 の曲線で近似する
							</span>
						</dt>
						<dd>
							sRGB ディスプレイの EOTF は、これまでガンマ 2.2 の曲線で近似してきました。
							ガンマ 2.2 の曲線は、
							精度を落としても問題にならないケースでは、
							ガンマ 2.0 の曲線で近似することができます。
							ガンマ 2.0 であれば、
							指数関数は2乗、対数関数は平方根になります。
							2乗は乗算で高速に実行できます。
							平方根の計算も、様々な近似手法で精度と引き換えに高速化が可能です
							（逆数平方根を利用したものや、IEEE754 のハックを利用したもの等々、
							詳細な説明はネット上に詳しい記事が山盛りあるのでそちらに譲ります）。
							<br/><br/>
						</dd>

						<dt>
							<span class="emphasis2">
								ガンマ2.0 の曲線で近似した結果
							</span>
						</dt>
						<dd>
							<center>
								<img src="1_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
								<img src="6_nearest.png" alt="入力画像" border="2" width="45%" height="45%"/>
								<br/>
								入力画像
							</center>
							<br/>

							<center>
								<img src="4_smoothstep_gamma.png" alt="smoothstep利用" border="2" width="45%" height="45%"/>
								<img src="9_smoothstep_gamma.png" alt="smoothstep利用" border="2" width="45%" height="45%"/>
								<br/>
								補間率に smoothstep を適用しバイリニアフィルタした結果。
								<br/>
								ガンマ 2.2 で処理した場合。
							</center>
							<br/>

							<center>
								<img src="5_smoothstep_gamma_2.0.png" alt="smoothstep利用ガンマ2.0" border="2" width="45%" height="45%"/>
								<img src="10_smoothstep_gamma_2.0.png" alt="smoothstep利用" border="2" width="45%" height="45%"/>
								<br/>
								補間率に smoothstep を適用しバイリニアフィルタした結果。
								<br/>
								ガンマ 2.0 で処理した場合。
							</center>
							<br/>

							ガンマ 2.2 とした場合とガンマ 2.0 とした場合の差は、
							目視ではほとんど気づかないレベルのわずかな差であることがわかります。
							ユースケース次第ですが、ガンマ 2.0 近似は十分に実用可能です。
						</dd>
					</dl>
				</dd>
			</dl>


			<h2>
				まとめ
			</h2>

			レトロゲームのドットを拡大する際、
			EOTF を考慮しないと正しい絵にならないことを、
			実験から確認しました。
			<br/><br/>

			EOTF を考慮したバイリニアフィルタを実装しました。
			<br/><br/>

			改良として、ドット感を残したバイリニアフィルタを実装しました。
			<br/><br/>

			改良として、EOTF をより低負荷な式で近似することによる高速化を行いました。
			<br/><br/>


			<h2>
				謝辞
			</h2>
			テスト用の画像データとして、
			<a href="https://littlelimit.net/misaki.htm">
				美咲フォント（みさきフォント）
			</a>
			を利用させていただきました。
			制作者である 門真 なむ 様に感謝いたします。
			<br/><br/>


			<hr/>
			2023/05/31 初出
			<br/>
			文責：
			<a href="../../about/index.html">
				よっしん
			</a>
			<br/><br/>


			<a href="../../index.html">
				[戻る]
			</a>
		</div>
	</body>
</html>

